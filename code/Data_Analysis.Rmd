---
title: "Projet GMM5 2017"
author: "Nathalie Villa-Vialaneix, Gicu Stratan and Soizick Magon de La Giclais"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    toc: yes
  pdf_document:
    toc: yes
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This files is a summary of the work made by GMM5 students on data coming from
ENVT study. 

The data are processed using the following packages:

```{r loadLib, message=FALSE}
library(mixOmics)
library(metagenomeSeq)
library(reshape2)
```

# Data description

Data are given in two files included in the directory ```data``` :

* the first one is the file ```abondances.csv``` that contains microbiote data:

```{r readAbondances ,cache=TRUE}
df_abundances <- read.delim("../data/abondances.csv", sep = ",", 
                            stringsAsFactors = FALSE)
summary(df_abundances[ ,1:15])
```

The first 9 columns contain information about the different bacteria identified 
within samples. The following columns contain the two technical replicates 
(identified by "A" and "B") of all the farms involved in the study (the farm is
identified by a number preceeding the letter "A"/"B"). 

Note that some "blast taxonomy" are duplicated:

```{r duplicatedTaxonomy ,cache=TRUE}
unique(names(which(table(df_abundances[ ,1]) > 1)))
```

as well as some of the bast id themselves

```{r duplicatedBlast, cache=TRUE}
unique(names(which(table(df_abundances[ ,2]) > 1)))
```


# Microbiote analysis

## Preprocessing and normalization

First, the two technical replicates are merged (simple sums as the counts have
already been normalized to identical library sizes)

```{r countSum ,cache=TRUE}
abundances <- df_abundances[ ,grep("A_", colnames(df_abundances))] +
  df_abundances[ ,grep("B_", colnames(df_abundances))]
dim(abundances)
```

which leads to `r ncol(abundances)` samples (columns) in which 
`r nrow(abundances)` bacteria have been observed (rows).

Condition ("EN" or "LBA") is extracted from column names:

```{r condition ,cache=TRUE}
condition <- rep("LBA", ncol(abundances))
condition[grep("EN", colnames(abundances))] <- "EN"
condition <- factor(condition)
table(condition)
```

Also, the farm identifier is extracted from column names:

```{r farmID ,cache=TRUE}
id_abundances <- as.character(colnames(abundances))
id_abundances <- sapply(id_abundances, function(ac) 
  substr(ac, nchar(ac) - 19, nchar(ac) - 18))
id_abundances <- gsub("A", "0", id_abundances)
id_abundances <- gsub("N", "0", id_abundances)
table(id_abundances)
```

All but one farm (idenfier: `r names(which(table(id_abundances) == 1))`) have 
been sampled twice, once for each condition.

## Merging duplicates

One species name is not correct. Let us change it with the right name:
```{r}
df_abundances[grep("&",df_abundances[ ,1]),1] <- "Bacteria;Proteobacteria;Gammaproteobacteria;Pasteurellales;Pasteurellaceae;Mannheimia;Mannheimia haemolytica"
```

Duplicated species (based on identical taxonomies) are then merged (counts are
summed). To do so, first simplified species names are obtained (last unknown 
species for every row):
```{r extractSpecies ,cache=TRUE}
species <- sapply(df_abundances[ ,1], function(aname) 
  strsplit(aname, ";"))
species <- sapply(species, function(avect) {
  find_unknown <- grep("unknown", avect)
  if (length(find_unknown) > 0) {
    return(avect[-find_unknown])
  } else return(avect)
})
species <- unlist(sapply(species, function(avect) avect[length(avect)]))
species <- unname(species)
```

Then, counts corresponding to the same simplified name are summed:

```{r mergedTaxon ,cache=TRUE}
abundances <- apply(abundances, 2, function(acol) tapply(acol, species, sum))
```

and the species names are retrieved:
```{r finalSpecies ,cache=TRUE}
species <- rownames(abundances)
colnames(abundances) <- paste(condition,id_abundances,sep='_')
```

One species has an unexpected name:
```{r exploreSpecies ,cache=TRUE}
head(species)
```

that corresponds to the row number `r grep("&", df_abundances[ ,1])` in the
original data (checked also directly in the file sent by Elias on 10/09).

## Exploratory analysis: distribution of one sample

The effect of different normalization is first explored by analyzing the distributions of the counts in the first sample before and after normalization.
Distribution before normalization is provided as:

```{r distBefore ,cache=TRUE}
df <- data.frame(abundances)
names(df) <- paste0("sample", 1:ncol(df))
ggplot(df, aes(x = sample1 +1)) + geom_histogram(bins = 50) + scale_y_log10() +
  theme_bw(base_size = 18) + xlab("counts (sample 1)") + ggtitle("Sample 1 distribution in raw data")
```

and with a log-transformation by

```{r distLog ,cache=TRUE}
df <- as.data.frame(log(abundances+1))
names(df) <- paste0("sample", 1:ncol(df))
ggplot(df, aes(x = sample1 + 1)) + geom_histogram(bins = 50) +
  theme_bw(base_size = 18) + xlab("counts (sample 1)") + 
  ggtitle("Sample 1 distribution (log)")
```

It is commun in metagenomic datasets to perform TSS (*Total Sum Scaling*) before
further normalization. TSS transformation computes relative abundances:
\[
  y_{ij} = \frac{n_{ij}}{\sum_{k=1}^p n_{ik}}
\]
for $n_{ij}$ the counts of species $j$ in sample $i$, $p$ the number of species
and $n$ the number of individuals.

```{r TSS ,cache=TRUE}
abundances_TSS <- apply(abundances, 1, function(asample)  asample / sum(asample))
df <- as.data.frame(t(abundances_TSS))
names(df) <- paste0("sample", 1:ncol(df))
dim(df)
ggplot(df, aes(x = sample1 + 1)) + geom_histogram(bins = 50) +
  theme_bw(base_size = 18) + xlab("relative abundance (sample 1)") + scale_x_log10() + ggtitle("Sample 1 distribution (TSS)")
```

The next two histograms are based on the normalized counts with:

* CLR (*Centered Log Ratio*) transformation: 
\[
  \tilde{y}_{ij} = \log \frac{y_{ij}}{\sqrt[p]{\prod_{k=1}^p y_{ik}}}.
\]

```{r CLRdist ,cache=TRUE}
abundances_CLR <- logratio.transfo(abundances_TSS, logratio = "CLR", 
                                   offset = 1)
class(abundances_CLR) <- "matrix"
df <- data.frame(t(abundances_CLR))   
names(df) <- paste0("sample", 1:ncol(df))
dim(df)
ggplot(df, aes(x = sample1)) + geom_histogram(bins = 50) + theme_bw(base_size = 18) + 
  xlab("counts (sample 1)") + ggtitle("Sample 1 distribution (CLR)")
```

* ILR (*Isometric Log Ratio*) transformation 
\[
  \tilde{\mathbf{Y}}' = \tilde{\mathbf{Y}} \times \mathbf{V}
\]
for $\tilde{\mathbf{Y}}$ the matrix of CLR transformed data and a given matrix
$\mathbf{V}$ with $p$ rows and $p-1$ columns such that $\mathbf{V} 
\mathbf{V}^\top = \mathbb{I}_{p-1}$ and $\mathbf{V}^\top \mathbf{V} = 
\mathbb{I} + a \mathbf{1}$, $a$ being any positive number and $\mathbf{1}$ a 
vector full of 1.

```{r IRLdist,cache=TRUE}
abundances_ILR <- logratio.transfo(abundances_TSS, logratio = "ILR", 
                                   offset = 1)
class(abundances_ILR) <- "matrix"
df <- data.frame(t(abundances_ILR)) 
names(df) <- paste0("sample", 1:ncol(df))
dim(df)
ggplot(df, aes(x = sample1)) + geom_histogram(bins = 50) + 
  theme_bw(base_size = 18) + xlab("counts (sample 1)") + 
  ggtitle("Sample 1 distribution (ILR)")
```

* CSS transformation, which is an adaptative extension for metagenomic data of
the quantile normalization used in microarray expression datasets. It is 
designed so as to account for technical differences between samples. 

```{r CSSdist ,cache=TRUE}
abundances_CSS <- newMRexperiment(abundances)
abundances_CSS <- cumNorm(abundances_CSS)
df <- data.frame(MRcounts(abundances_CSS))
names(df) <- paste0("sample", 1:ncol(df))
dim(df)
ggplot(df, aes(x = sample1 + 1)) + geom_histogram(bins = 50) + 
  theme_bw(base_size = 18) + xlab("counts (sample 1)") + 
  scale_y_log10() + scale_x_log10()+ ggtitle("Sample 1 distribution (CSS)")
```

The less asymetric distribution seems to be the one obtained with the CLR 
transformation and the log-transformed CSS.

## Exploratory analysis: distribution of all samples

Distributions of all samples according to the type of transformation and the 
sample is provided below:

```{r allBoxplots, message=FALSE ,cache=TRUE}
df_log <- log10(abundances + 1)
df_log <- data.frame(df_log)
rownames(df_log) <- NULL
names(df_log) <- paste0("Sample", 1:ncol(df_log))
df_log <- melt(df_log)
df_CLR <- data.frame(t(abundances_CLR))
names(df_CLR) <- paste0("Sample", 1:ncol(df_CLR))
df_CLR <- melt(df_CLR)
df_ILR <- data.frame(t(abundances_ILR))
names(df_ILR) <- paste0("Sample", 1:ncol(df_ILR))
df_ILR <- melt(df_ILR)
df_CSS <- data.frame(log(MRcounts(abundances_CSS)) + 1)
names(df_CSS) <- paste0("Sample", 1:ncol(df_CSS))
df_CSS <- melt(df_CSS)
all_sizes <- c(nrow(df_log), nrow(df_CLR), nrow(df_ILR), nrow(df_CSS))
df <- data.frame(rbind(df_log, df_CLR, df_ILR, df_CSS),
                 "type" = rep(c("log", "CLR", "ILR", "log-CSS"), all_sizes))
ggplot(df, aes(x = variable, y = value)) + geom_boxplot() + theme_bw(base_size = 18) +
  facet_wrap(~ type, scales = "free_y") + xlab("samples") +
  theme(axis.text.x = element_blank())
```

## Exploratory analysis: PCA

**Log**

A first exploratory analysis is performed with PCA on (merged) raw counts with
log transformation:

```{r pcaRaw ,cache=TRUE}
pca_raw <- pca(log(t(abundances) + 1), ncomp = ncol(abundances), 
               logratio = 'none')
plot(pca_raw)
```

that shows a good percentage of explained variance for the first axis. 

Projection of the individuals on the first two PCs also shows a good separation between the two conditions:

```{r pcaRawIndiv ,cache=TRUE}
plotIndiv(pca_raw, 
          comp = c(1,2),
          pch = 16, 
          ind.names = FALSE, 
          group = condition, 
          col.per.group = color.mixo(1:2),
          legend = TRUE,
          title="PCA for log-tranformed data",
          size.title = rel(2.5),
          size.ylabel = rel(1.5),
          size.xlabel = rel(1.5),
          size.legend.title = rel(1.5),cex=4)
```

**TSS+CLR**

The same analysis is used with TSS normalized counts subsequently transformed by CLR or ILR (which is the expected analysis):

```{r pcaCLR, cache=TRUE}
pca_CLR <- pca(abundances_TSS + 1, ncomp = nrow(abundances_TSS),
               logratio = 'CLR')
plot(pca_CLR)
plotIndiv(pca_CLR, 
          comp = c(1,2),
          pch = 16, 
          ind.names = FALSE, 
          group = condition, 
          col.per.group = color.mixo(1:2),
          legend = TRUE,
          title="PCA for CLR-tranformed data")
```

**TSS+ILR**

```{r pcaILR}
pca_ILR <- pca(abundances_TSS + 1, ncomp = nrow(abundances_TSS) - 1,
               logratio = 'ILR')
plot(pca_ILR)
plotIndiv(pca_ILR, 
          comp = c(1,2),
          pch = 16, 
          ind.names = FALSE, 
          group = condition, 
          col.per.group = color.mixo(1:2),
          legend = TRUE,
          title="PCA for ILR-tranformed data")
```

**CSS**

```{r pcaCSS}
log_CSS <- log(MRcounts(abundances_CSS) + 1)
pca_CSS <- pca(t(log_CSS), ncomp = ncol(log_CSS))
plot(pca_CSS)
plotIndiv(pca_CSS, 
          comp = c(1,2),
          pch = 16, 
          ind.names = FALSE, 
          group = condition, 
          col.per.group = color.mixo(1:2),
          legend = TRUE,
          title="PCA for CSS-tranformed data")
```

## Differences between the two types of samples

A first ***PLS-DA*** is computed (with 10-fold CV) to check the efficiency of the method and which type of distance to use in its computation. 

### with log transformation

```{r distCV, cache=TRUE}
set.seed(11)
res_plsda <- plsda(log(t(abundances)+1), condition, ncomp = nlevels(condition))
res_perf <- perf(res_plsda, validation = 'Mfold', folds = 5,
                  progressBar = FALSE, nrepeat = 20)
plot(res_perf, overlay = 'measure', sd = TRUE)
plotIndiv(res_plsda , comp = c(1, 2), ind.names = FALSE, ellipse = TRUE, 
          legend = TRUE, title = 'PLS-DA Comp 1 - 2')
```

PLS-DA shows a good separation between the two groups and indicates that the Mahalanobis distance provides the lower overall classification error.

Then, sparse PLS-DA is used (with the multilevel approach) to check which number
of components to select. 

**Creation of data set log transformed and without the calf 29:**
  
```{r cleandata, cache=TRUE}
clean_log <- data.frame(log(t(abundances[ ,id_abundances != "29"]) + 1))
names(clean_log) <- species
clean_condition <- factor(condition[id_abundances != "29"])
clean_id <- factor(id_abundances[id_abundances != "29"])
```

```{r ,cache=TRUE}

set.seed(33)
res_plsda <- tune.splsda(clean_log, clean_condition, 
                         ncomp = nlevels(clean_condition),
                         multilevel = clean_id,
                         test.keepX = 1:20, validation = 'Mfold', folds = 10, 
                         dist = 'mahalanobis.dist', nrepeat = 10,
                         progressBar = FALSE)

plot(res_plsda)

sel_keepX <- res_plsda$choice.keepX[1:2]
sel_keepX
```

Finally sparse PLS-DA is performed and the variables explaining the two types of samples are obtained:

```{r finalPLS-DA}
res_splsda <- splsda(clean_log, clean_condition, 
                     ncomp = nlevels(clean_condition), multilevel = clean_id,
                     keepX = sel_keepX)

plotIndiv(res_splsda, comp = c(1,2), ind.names = FALSE, ellipse = TRUE, 
          legend = TRUE, title = 'sPLS-DA Comp 1 - 2')
```

```{r interpretation}
head(selectVar(res_splsda, comp = 1)$name)
plotLoadings(res_splsda, comp = 1, method = 'mean', contrib = 'max',
             size.title = 1)
plotLoadings(res_splsda, comp = 2, method = 'mean', contrib = 'max',
             size.title = 1)
```

```{r ,eval=FALSE}
# cim(res_splsda,comp=1,row.names = paste(clean_id,clean_condition,sep='_'),title="Heatmap with splsda values")
# test<-clean_log[,which(species%in%selectVar(res_splsda, comp = 1)$name)]
# cim(sapply(test,as.numeric),row.names = paste(clean_id,clean_condition,sep='_'),title="Heatmap with clean_log values")
```

**EN vs LBA: Student test on selected Variables**

```{r ,cache=TRUE}
selected <- selectVar(res_splsda, comp = 1)$name
for (ind in seq_along(selected)) {
  df <- data.frame(counts = abundances[selected[ind], ], 
                   condition = condition)
  p <- ggplot(df, aes(x = condition, y = counts + 1, fill = condition)) +
    geom_boxplot() + theme_bw() + scale_y_log10() + 
    scale_fill_manual(values = c("dodgerblue2","darkorange")) +
    ggtitle(selected[ind]) + ylab(expression(log[10] ~ "(count + 1)"))
  print(p)
}
```

```{r}
all_pvals <- sapply(seq_along(selected), function(ind) {
  var_en <- clean_log[clean_condition == "EN",selected[ind]]
  var_lba <- clean_log[clean_condition == "LBA",selected[ind]]
  pval <- t.test(var_en, var_lba, paired = TRUE)$p.value
})
res <- data.frame(bacteria = selected, pvalue = all_pvals,
                  FWER = p.adjust(all_pvals, method = "BH"))
res
```

All tests are found positive: those bacteria are found differentially present in `EN/LBA` samples.

### with TSS+CLR transformation

```{r distCV1, cache=TRUE,eval=FALSE}
abundances_CLR <- data.frame(abundances_CLR)
names(abundances_CLR) <- species

set.seed(11)
res_plsda <- plsda(abundances_CLR, condition, ncomp = nlevels(condition))
res_perf <- perf(res_plsda, validation = 'Mfold', folds = 5,
                 progressBar = FALSE, nrepeat = 20)
plot(res_perf, overlay = 'measure', sd = TRUE)
plotIndiv(res_plsda , comp = c(1, 2), ind.names = FALSE, ellipse = TRUE, 
          legend = TRUE, title = 'PLS-DA (CLR)')
```

```{r keepCV1, cache=TRUE,eval=FALSE}
clean_CLR <- data.frame(abundances_CLR[id_abundances != "29", ])
names(clean_CLR) <- species

set.seed(33)
res_plsda <- tune.splsda(clean_CLR, clean_condition, 
                         ncomp = nlevels(clean_condition),
                         multilevel = clean_id,
                         test.keepX = 1:20, validation = 'Mfold', 
                         folds = 10, dist = 'mahalanobis.dist', nrepeat = 10,
                         progressBar = FALSE)

plot(res_plsda)

sel_keepX <- res_plsda$choice.keepX[1:2]
sel_keepX
```

```{r finalPLS-DA1,eval=FALSE}
res_splsda <- splsda(clean_CLR, clean_condition, 
                     ncomp = nlevels(clean_condition), multilevel = clean_id,
                     keepX = sel_keepX)

plotIndiv(res_splsda, comp = c(1,2), ind.names = FALSE, ellipse = TRUE, 
          legend = TRUE, title = 'sPLS-DA (CLR)')
```

```{r interpretation1,eval=FALSE}
plotLoadings(res_splsda, comp = 1, method = 'mean', contrib = 'max')
plotLoadings(res_splsda, comp = 2, method = 'mean', contrib = 'max')
```


### with CSS transformation

```{r distCV5, cache=TRUE}
abundances_CSS <- data.frame(t(log_CSS))
names(abundances_CSS) <- species

set.seed(11)
res_plsda <- plsda(abundances_CSS, condition, ncomp = nlevels(condition))
res_perf <- perf(res_plsda, validation = 'Mfold', folds = 5,
                 progressBar = FALSE, nrepeat = 20)
plot(res_perf, overlay = 'measure', sd = TRUE)
plotIndiv(res_plsda , comp = c(1, 2), ind.names = FALSE, ellipse = TRUE, 
          legend = TRUE, title = 'PLS-DA (CSS)')
```

```{r keepCV5, cache=TRUE}
clean_CSS <- data.frame(abundances_CSS[id_abundances != "29", ])
names(clean_CSS) <- species

set.seed(33)
res_plsda <- tune.splsda(clean_CSS, clean_condition, 
                         ncomp = nlevels(clean_condition),
                         multilevel = clean_id,
                         test.keepX = 1:20, validation = 'Mfold', 
                         folds = 10, dist = 'mahalanobis.dist', nrepeat = 10,
                         progressBar = FALSE)

plot(res_plsda)

sel_keepX <- res_plsda$choice.keepX[1:2]
sel_keepX
```

```{r finalPLS-DA5}
res_splsda <- splsda(clean_CSS, clean_condition, 
                     ncomp = nlevels(clean_condition), multilevel = clean_id,
                     keepX = sel_keepX)

plotIndiv(res_splsda, comp = c(1,2), ind.names = FALSE, ellipse = TRUE, 
          legend = TRUE, title = 'sPLS-DA (CSS)')
```

```{r interpretation5}
plotLoadings(res_splsda, comp = 1, method = 'mean', contrib = 'max')
plotLoadings(res_splsda, comp = 2, method = 'mean', contrib = 'max')
```


### with log transformation (but not paired)

```{r keepCV2, cache=TRUE}
set.seed(33)
res_plsda <- tune.splsda(log(t(abundances)+1), condition, 
                         ncomp = nlevels(condition), 
                         test.keepX = 1:20, validation = 'Mfold', 
                         folds = 10, dist = 'mahalanobis.dist', nrepeat = 10,
                         progressBar = FALSE)

plot(res_plsda)

sel_keepX <- res_plsda$choice.keepX[1:2]
sel_keepX
```

```{r finalPLS-DA2}
res_splsda <- splsda(log(t(abundances)+1), condition, 
                     ncomp = nlevels(condition), keepX = sel_keepX)

plotIndiv(res_splsda, comp = c(1,2), ind.names = FALSE, ellipse = TRUE, 
          legend = TRUE, title = 'sPLS-DA (log)')
```

```{r interpretation2}
plotLoadings(res_splsda, comp = 1, method = 'mean', contrib = 'max',
             size.title = 1)
plotLoadings(res_splsda, comp = 2, method = 'mean', contrib = 'max',
             size.title = 1)
```


### with TSS+CLR transformation (not paired)

```{r distCV3, cache=TRUE,eval=FALSE}
set.seed(11)
res_plsda <- plsda(abundances_CLR, condition, ncomp = nlevels(condition))
res_perf <- perf(res_plsda, validation = 'Mfold', folds = 5, 
                 progressBar = FALSE, nrepeat = 20)
plot(res_perf, overlay = 'measure', sd = TRUE)
plotIndiv(res_plsda , comp = c(1, 2), ind.names = FALSE, ellipse = TRUE, 
          legend = TRUE, title = 'PLS-DA (CLR)')
```

```{r keepCV3, cache=TRUE,eval=FALSE}
set.seed(33)
res_plsda <- tune.splsda(abundances_CLR, condition, ncomp = nlevels(condition),
                         test.keepX = 1:20, validation = 'Mfold', 
                         folds = 10, dist = 'mahalanobis.dist', nrepeat = 10,
                         progressBar = F)

plot(res_plsda)

sel_keepX <- res_plsda$choice.keepX[1:2]
sel_keepX
```

```{r finalPLS-DA3,eval=FALSE}
res_splsda <- splsda(abundances_CLR, condition, ncomp = nlevels(condition),
                     keepX = sel_keepX)

plotIndiv(res_splsda, comp = c(1,2), ind.names = FALSE, ellipse = TRUE, 
          legend = TRUE, title = 'sPLS-DA (CLR)')
```

```{r interpretation3,eval=FALSE}
plotLoadings(res_splsda, comp = 1, method = 'mean', contrib = 'max',
             size.title = 1)
plotLoadings(res_splsda, comp = 2, method = 'mean', contrib = 'max',
             size.title = 1)
```


# Random Forest

In this section will be performed **Random Forest** algorithm for classification, with a virus as response vector and all bacteria as explanatory variables in the model.

```{r , message=FALSE}
library(randomForest,quietly=T)
```

**Data preparation:**

```{r ,cache=TRUE}
df_pathogenes<-read.delim("../data/pathogenes.csv",sep = ",")
pathogenes<-df_pathogenes[,-c(1,9)]
pathogenes<-as.data.frame(ifelse(pathogenes=='p',1,0))
pathogenes<-as.data.frame(apply(t(pathogenes),1,as.factor))
id_pathogenes<-df_pathogenes[,1]
id_pathogenes <- gsub("-","0",id_pathogenes)
id_pathogenes <- gsub(" ","",id_pathogenes)
id_pathogenes <- sapply(as.character(id_pathogenes),FUN=function(x){substr(x,nchar(x)-1,nchar(x))})
id_pathogenes <- id_pathogenes[id_pathogenes!="29"]
id_pathogenes <- paste0(id_pathogenes,"_",rev(condition[id_abundances!="29"]))
```

The list of calf names is not in the same order in the `pathogenes` file as in the `abundances` file. The `abundances` file order will be kept:

```{r ,cache=TRUE}
id_abundances_bis <- paste0(id_abundances[-grep("29",id_abundances)],"_",
                            condition[-grep("29",id_abundances)])
pathogenes <- pathogenes[df_pathogenes[,1]!="ICSA-29",]
Y<-pathogenes[match(id_abundances_bis,id_pathogenes),] 
rownames(Y)<-id_abundances_bis
```

`Y` contains the seven response vectors.

```{r}
cat(" 0  1\n\n")
for (virus in colnames(Y)){
  cat(virus,"\n",table(Y[,virus]),fill=T)
}
```

The bacteria names are too long for the plots, they will be renamed:

```{r }
X <- clean_log
X <- as.data.frame(sapply(X,as.integer))
colnames(X)<- make.names(names(X))
```

## Random Forest on both conditions

### Random Forest on `RSV`:

```{r ,cache=TRUE}
fit <- randomForest(Y$Ct.RSV ~ ., data = X,classwt=table(Y$Ct.RSV),ntree=3000)
fit$confusion
```

```{r ,eval=FALSE}
varImpPlot(fit)
round(fit$importance[order(fit$importance[, 1], decreasing = TRUE), ][1:5],3)
plot(fit$err.rate[, 1], type = "l", xlab = "number of trees", ylab = "error OOB")
```

```{r ,eval=FALSE}
cat(fit$predicted)
```

### Random Forest on `PI.3`:

```{r ,cache=TRUE}
fit <- randomForest(Y$Ct.PI.3 ~ ., data = X,classwt=table(Y$Ct.PI.3),ntree=1000,mtry=10)
fit$confusion
```
Nothing in class `1`...
```{r ,eval=FALSE}
varImpPlot(fit)
round(fit$importance[order(fit$importance[, 1], decreasing = TRUE), ][1:5],3)
plot(fit$err.rate[, 1], type = "l", xlab = "number of trees", ylab = "error OOB")
```

### Random Forest on `Coronavirus`:

```{r ,cache=TRUE}
fit <- randomForest(Y$Ct.Coronavirus ~ .,data = X,classwt=table(Y$Ct.Coronavirus)
                    , ntree=2000,mtry=16)
fit$confusion
```
High error
```{r ,eval=FALSE}
varImpPlot(fit)
fit$importance[order(fit$importance[, 1], decreasing = TRUE), ][1:5]
plot(fit$err.rate[, 1], type = "l", xlab = "number of trees", ylab = "error OOB")
```

### Random Forest on `P.multocida`:

```{r ,cache=TRUE}
fit <- randomForest(Y$Ct.P.multocida ~ ., data = X,classwt=table(Y$Ct.P.multocida),ntree=1000,mtry=16)
fit$confusion
```
Nothing in class `0`
```{r ,eval=FALSE}
varImpPlot(fit)
fit$importance[order(fit$importance[, 1], decreasing = TRUE), ][1:5]
plot(fit$err.rate[, 1], type = "l", xlab = "nombre d'arbres", ylab = "erreur OOB")
```

### Random Forest on `M.haemolytica`:

```{r ,cache=TRUE}
fit <- randomForest(Y$Ct.M.haemolytica ~ ., data = X,classwt=table(Y$Ct.M.haemolytica),ntree=1000,mtry=40)
fit$confusion
```

```{r ,eval=FALSE}
varImpPlot(fit)
fit$importance[order(fit$importance[, 1], decreasing = TRUE), ][1:5]
plot(fit$err.rate[, 1], type = "l", xlab = "number of trees", ylab = "error OOB")
```

### Random Forest on `M.bovis`:

```{r ,cache=TRUE}
fit <- randomForest(Y$Ct.M.bovis ~ ., data = X,classwt=table(Y$Ct.M.bovis) , ntree=500,mtry=40)
fit$confusion
```

```{r ,eval=FALSE}
varImpPlot(fit)
fit$importance[order(fit$importance[, 1], decreasing = TRUE), ][1:5]
plot(fit$err.rate[, 1], type = "l", xlab = "number of trees", ylab = "error OOB")
```

### Random Forest on `H.somni`:

```{r ,cache=TRUE}
fit <- randomForest(Y$Ct.H.somni ~ ., data = X,classwt=table(Y$Ct.H.somni),ntree=1000,mtry=16)
fit$confusion
```

```{r ,eval=FALSE}
varImpPlot(fit)
fit$importance[order(fit$importance[, 1], decreasing = TRUE), ][1:5]
plot(fit$err.rate[, 1], type = "l", xlab = "number of trees", ylab = "error OOB")
```

## Random Forest on `EN` condition

Study only on EN condition samples
```{r}
X_EN<-X[grep("EN",colnames(abundances)),]
X_LBA<-X[grep("LBA",rownames(Y)),]
Y_EN<-Y[grep("EN",colnames(abundances)),]
Y_LBA<-Y[grep("LBA",rownames(Y)),]

clean_log_EN <- clean_log[grep("EN",rownames(clean_log)),]
clean_id_EN <- clean_id[grep("EN",names(clean_id))]
clean_log_LBA <- clean_log[grep("LBA",rownames(clean_log)),]
clean_id_LBA <- clean_id[grep("LBA",names(clean_id))]
```

### Random Forest on `RSV` - `EN` condition:

```{r ,cache=TRUE}
fit <- randomForest(Y_EN$Ct.RSV ~ ., data = X_EN,classwt=table(Y_EN$Ct.H.somni), ntree=5000)
fit$confusion
```

### Random Forest on `PI.3` - `EN` condition:

```{r ,cache=TRUE}
fit <- randomForest(Y_EN$Ct.PI.3 ~ ., data = X_EN,classwt=table(Y_EN$Ct.H.somni), ntree=5000)
fit$confusion
```
### Random Forest on `Coronavirus` - `EN` condition:

```{r ,cache=TRUE}
fit <- randomForest(Y_EN$Ct.Coronavirus ~ ., data = X_EN,classwt=table(Y_EN$Ct.H.somni), ntree=5000)
fit$confusion
```
### Random Forest on `M.haemolytica` - `EN` condition:

```{r ,cache=TRUE}
fit <- randomForest(Y_EN$Ct.M.haemolytica~ ., data = X_EN,classwt=table(Y_EN$Ct.H.somni), ntree=5000)
fit$confusion
```
### Random Forest on `M.bovis` - `EN` condition:

```{r ,cache=TRUE}
fit <- randomForest(Y_EN$Ct.M.bovis~ ., data = X_EN,classwt=table(Y_EN$Ct.H.somni), ntree=5000)
fit$confusion
```

### Random Forest on `P.multocida` - `EN` condition:

```{r ,cache=TRUE}
fit <- randomForest(Y_EN$Ct.P.multocida ~ ., data = X_EN,classwt=table(Y_EN$Ct.H.somni), ntree=5000)
fit$confusion
```

### Random Forest on `H.somni` - `EN` condition:

```{r ,cache=TRUE}
fit <- randomForest(Y_EN$Ct.H.somni ~ ., data = X_EN,classwt=table(Y_EN$Ct.H.somni), ntree=5000)
fit$confusion
```

# PLS-DA on viruses

## PLS-DA on `RSV`

```{r distCVY1, cache=TRUE}
set.seed(11)
res_plsda <- plsda(X=clean_log,Y=Y$Ct.RSV, ncomp = nlevels(clean_condition))
res_perf <- perf(res_plsda, validation = 'Mfold', folds = 5,
                 progressBar = FALSE, nrepeat = 20)
plot(res_perf, overlay = 'measure', sd = TRUE)
plotIndiv(res_plsda , comp = c(1, 2), ind.names = FALSE, ellipse = TRUE, 
          legend = TRUE, title = 'PLS-DA (RSV)')
```

```{r keepCVY1, cache=TRUE}
set.seed(33)
res_plsda <- tune.splsda(X=clean_log,Y=Y$Ct.RSV, 
                         ncomp = nlevels(clean_condition),
                         multilevel = clean_id,
                         test.keepX = 1:20, validation = 'Mfold', 
                         folds = 10, dist = 'mahalanobis.dist', nrepeat = 10,
                         progressBar = F)

plot(res_plsda)

sel_keepX <- res_plsda$choice.keepX[1:2]
sel_keepX
```

```{r finalPLS-DAY1, cache=TRUE}
res_splsda <- splsda(X=clean_log,Y=Y$Ct.RSV, 
                     ncomp = nlevels(clean_condition),
                     multilevel = clean_id,
                     keepX = sel_keepX)

plotIndiv(res_splsda, comp = c(1,2), ind.names = FALSE, ellipse = TRUE, 
          legend = TRUE, title = 'sPLS-DA (RSV)')
```

```{r ,cache=TRUE}
test <- predict(res_splsda,clean_log)
pred <- test$class$mahalanobis.dist[,2]
get.confusion_matrix(Y$Ct.RSV,predicted=pred)
```

```{r interpretationY1}
head(selectVar(res_splsda, comp = 1)$name)
plotLoadings(res_splsda, comp = 1, method = 'mean', contrib = 'max',
             size.title = 1)
plotLoadings(res_splsda, comp = 2, method = 'mean', contrib = 'max',
             size.title = 1)
```

## PLS-DA on `PI.3`

```{r distCVY2, cache=TRUE}
set.seed(11)
res_plsda <- plsda(X=clean_log,Y=Y$Ct.PI.3, ncomp = nlevels(clean_condition))
res_perf <- perf(res_plsda, validation = 'Mfold', folds = 5,
                 progressBar = FALSE, nrepeat = 20)
plot(res_perf, overlay = 'measure', sd = TRUE)
plotIndiv(res_plsda , comp = c(1, 2), ind.names = FALSE, ellipse = TRUE, 
          legend = TRUE, title = 'PLS-DA (PI.3)')
```

```{r keepCVY2, cache=TRUE, eval=FALSE}
set.seed(33)
res_plsda <- tune.splsda(X=clean_log,Y=Y$Ct.PI.3, 
                         ncomp = nlevels(clean_condition),
                         multilevel = clean_id,
                         test.keepX = 1:20, validation = 'Mfold', 
                         folds = 10, dist = 'mahalanobis.dist', nrepeat = 10,
                         progressBar = F)

plot(res_plsda)

sel_keepX <- res_plsda$choice.keepX[1:2]
sel_keepX
```

**ERROR:** 
Splitting the variation for 1 level factor.
The SGCCA algorithm did not convergeThe SGCCA algorithm did not convergeThe SGCCA algorithm did not convergeThe SGCCA algorithm did not convergeThe SGCCA algorithm did not convergeThe SGCCA algorithm did not convergeThe SGCCA algorithm did not convergeThe SGCCA algorithm did not convergeThe SGCCA algorithm did not convergeThe SGCCA algorithm did not convergeThe SGCCA algorithm did not convergeThe SGCCA algorithm did not convergeThe SGCCA algorithm did not convergeThe SGCCA algorithm did not convergeThe SGCCA algorithm did not convergeThe SGCCA algorithm did not convergeThe SGCCA algorithm did not convergeThe SGCCA algorithm did not convergeThe SGCCA algorithm did not convergeThe SGCCA algorithm did not converge

Error in `colnames<-`(`*tmp*`, value = c("0", "1")) : length of 'dimnames' [2] not equal to array extent

```{r finalPLS-DAY2, eval=FALSE}
res_splsda <- splsda(X=clean_log,Y=Y$Ct.PI.3, 
                     ncomp = nlevels(clean_condition),
                     multilevel = clean_id,
                     keepX = sel_keepX)

plotIndiv(res_splsda, comp = c(1,2), ind.names = FALSE, ellipse = TRUE, 
          legend = TRUE, title = 'sPLS-DA (PI.3)')
```

```{r interpretationY2, eval=FALSE}
head(selectVar(res_splsda, comp = 1)$name)
plotLoadings(res_splsda, comp = 1, method = 'mean', contrib = 'max',
             size.title = 1)
plotLoadings(res_splsda, comp = 2, method = 'mean', contrib = 'max',
             size.title = 1)
```

## PLS-DA on `Coronavirus`

```{r distCVY3, cache=TRUE}
set.seed(11)
res_plsda <- plsda(X=clean_log,Y=Y$Ct.Coronavirus, ncomp = nlevels(clean_condition))
res_perf <- perf(res_plsda, validation = 'Mfold', folds = 5,
                 progressBar = FALSE, nrepeat = 20)
plot(res_perf, overlay = 'measure', sd = TRUE)
plotIndiv(res_plsda , comp = c(1, 2), ind.names = FALSE, ellipse = TRUE, 
          legend = TRUE, title = 'PLS-DA (Coronavirus)')
```

```{r keepCVY3, cache=TRUE}
set.seed(33)
res_plsda <- tune.splsda(X=clean_log,Y=Y$Ct.Coronavirus, 
                         ncomp = nlevels(clean_condition),
                         multilevel = clean_id,
                         test.keepX = 1:20, validation = 'Mfold', 
                         folds = 10, dist = 'mahalanobis.dist', nrepeat = 10,
                         progressBar = F)

plot(res_plsda)

sel_keepX <- res_plsda$choice.keepX[1:2]
sel_keepX
```

```{r finalPLS-DAY3}
res_splsda <- splsda(X=clean_log,Y=Y$Ct.Coronavirus, 
                     ncomp = nlevels(clean_condition),
                     multilevel = clean_id,
                     keepX = sel_keepX)

plotIndiv(res_splsda, comp = c(1,2), ind.names = FALSE, ellipse = TRUE, 
          legend = TRUE, title = 'sPLS-DA (Coronavirus)')
```

Si on limite le nombre de variables, on n'arrive pas a discrimner de maniere lineaire la presence ou l'absence du Coronavirus.

```{r interpretationY3}
head(selectVar(res_splsda, comp = 1)$name)
plotLoadings(res_splsda, comp = 1, method = 'mean', contrib = 'max',
             size.title = 1)
plotLoadings(res_splsda, comp = 2, method = 'mean', contrib = 'max',
             size.title = 1)
```

## PLS-DA on `P.multocida`

```{r distCVY4, cache=TRUE}
set.seed(11)
res_plsda <- plsda(X=clean_log,Y=Y$Ct.P.multocida, ncomp = nlevels(clean_condition))
res_perf <- perf(res_plsda, validation = 'Mfold', folds = 5,
                 progressBar = FALSE, nrepeat = 20)
plot(res_perf, overlay = 'measure', sd = TRUE)
plotIndiv(res_plsda , comp = c(1, 2), ind.names = FALSE, ellipse = TRUE, 
          legend = TRUE, title = 'PLS-DA (P.multocida)')
```

```{r keepCVY4, cache=TRUE}
set.seed(33)
res_plsda <- tune.splsda(X=clean_log,Y=Y$Ct.P.multocida, 
                         ncomp = nlevels(clean_condition),
                         multilevel = clean_id,
                         test.keepX = 1:20, validation = 'Mfold', 
                         folds = 10, dist = 'mahalanobis.dist', nrepeat = 10,
                         progressBar = F)

plot(res_plsda)

sel_keepX <- res_plsda$choice.keepX[1:2]
sel_keepX
```

```{r finalPLS-DAY4}
res_splsda <- splsda(X=clean_log,Y=Y$Ct.P.multocida, 
                     ncomp = nlevels(clean_condition),
                     multilevel = clean_id,
                     keepX = sel_keepX)

plotIndiv(res_splsda, comp = c(1,2), ind.names = FALSE, ellipse = TRUE, 
          legend = TRUE, title = 'sPLS-DA (P.multocida)')
```

```{r interpretationY4}
head(selectVar(res_splsda, comp = 1)$name)
plotLoadings(res_splsda, comp = 1, method = 'mean', contrib = 'max',
             size.title = 1)
plotLoadings(res_splsda, comp = 2, method = 'mean', contrib = 'max',
             size.title = 1)
```

## PLS-DA on `M.haemolytica`

```{r distCVY5, cache=TRUE}
set.seed(11)
res_plsda <- plsda(X=clean_log,Y=Y$Ct.M.haemolytica, ncomp = nlevels(clean_condition))
res_perf <- perf(res_plsda, validation = 'Mfold', folds = 5,
                 progressBar = FALSE, nrepeat = 20)
plot(res_perf, overlay = 'measure', sd = TRUE)
plotIndiv(res_plsda , comp = c(1, 2), ind.names = FALSE, ellipse = TRUE, 
          legend = TRUE, title = 'PLS-DA (M.haemolytica)')
```

```{r keepCVY5, cache=TRUE}
set.seed(33)
res_plsda <- tune.splsda(X=clean_log,Y=Y$Ct.M.haemolytica, 
                         ncomp = nlevels(clean_condition),
                         multilevel = clean_id,
                         test.keepX = 1:20, validation = 'Mfold', 
                         folds = 10, dist = 'mahalanobis.dist', nrepeat = 10,
                         progressBar = F)

plot(res_plsda)

sel_keepX <- res_plsda$choice.keepX[1:2]
sel_keepX
```

```{r finalPLS-DAY5}
res_splsda <- splsda(X=clean_log,Y=Y$Ct.M.haemolytica, 
                     ncomp = nlevels(clean_condition),
                     multilevel = clean_id,
                     keepX = sel_keepX)

plotIndiv(res_splsda, comp = c(1,2), ind.names = FALSE, ellipse = TRUE, 
          legend = TRUE, title = 'sPLS-DA (M.haemolytica)')
```

```{r interpretationY5}
head(selectVar(res_splsda, comp = 1)$name)
plotLoadings(res_splsda, comp = 1, method = 'mean', contrib = 'max',
             size.title = 1)
plotLoadings(res_splsda, comp = 2, method = 'mean', contrib = 'max',
             size.title = 1)
```

## PLS-DA on `M.bovis`

```{r distCVY6, cache=TRUE}
set.seed(11)
res_plsda <- plsda(X=clean_log,Y=Y$Ct.M.bovis, ncomp = nlevels(clean_condition))
res_perf <- perf(res_plsda, validation = 'Mfold', folds = 5,
                 progressBar = FALSE, nrepeat = 20)
plot(res_perf, overlay = 'measure', sd = TRUE)
plotIndiv(res_plsda , comp = c(1, 2), ind.names = FALSE, ellipse = TRUE, 
          legend = TRUE, title = 'PLS-DA (M.bovis)')
```

```{r keepCVY6, cache=TRUE}
set.seed(33)
res_plsda <- tune.splsda(X=clean_log,Y=Y$Ct.M.bovis, 
                         ncomp = nlevels(clean_condition),
                         multilevel = clean_id,
                         test.keepX = 1:20, validation = 'Mfold', 
                         folds = 10, dist = 'mahalanobis.dist', nrepeat = 10,
                         progressBar = F)

plot(res_plsda)

sel_keepX <- res_plsda$choice.keepX[1:2]
sel_keepX
```

```{r finalPLS-DAY6}
res_splsda <- splsda(X=clean_log,Y=Y$Ct.M.bovis, 
                     ncomp = nlevels(clean_condition),
                     multilevel = clean_id,
                     keepX = sel_keepX)

plotIndiv(res_splsda, comp = c(1,2), ind.names = FALSE, ellipse = TRUE, 
          legend = TRUE, title = 'sPLS-DA (M.bovis)')
```

```{r interpretationY6}
head(selectVar(res_splsda, comp = 1)$name)
plotLoadings(res_splsda, comp = 1, method = 'mean', contrib = 'max',
             size.title = 1)
plotLoadings(res_splsda, comp = 2, method = 'mean', contrib = 'max',
             size.title = 1)
```

## PLS-DA on `H.somni`

```{r distCVY7, cache=TRUE}
set.seed(11)
res_plsda <- plsda(X=clean_log,Y=Y$Ct.H.somni, ncomp = nlevels(clean_condition))
res_perf <- perf(res_plsda, validation = 'Mfold', folds = 5,
                 progressBar = FALSE, nrepeat = 20)
plot(res_perf, overlay = 'measure', sd = TRUE)
plotIndiv(res_plsda , comp = c(1, 2), ind.names = FALSE, ellipse = TRUE, 
          legend = TRUE, title = 'PLS-DA (H.somni)')
```

```{r keepCVY7, cache=TRUE}
set.seed(33)
res_plsda <- tune.splsda(X=clean_log,Y=Y$Ct.H.somni, 
                         ncomp = nlevels(clean_condition),
                         multilevel = clean_id,
                         test.keepX = 1:20, validation = 'Mfold', 
                         folds = 10, dist = 'mahalanobis.dist', nrepeat = 10,
                         progressBar = F)

plot(res_plsda)

sel_keepX <- res_plsda$choice.keepX[1:2]
sel_keepX
```

```{r finalPLS-DAY7}
res_splsda <- splsda(X=clean_log,Y=Y$Ct.H.somni, 
                     ncomp = nlevels(clean_condition),
                     multilevel = clean_id,
                     keepX = sel_keepX)

plotIndiv(res_splsda, comp = c(1,2), ind.names = FALSE, ellipse = TRUE, 
          legend = TRUE, title = 'sPLS-DA (H.somni)')
```

```{r interpretationY7}
head(selectVar(res_splsda, comp = 1)$name)
plotLoadings(res_splsda, comp = 1, method = 'mean', contrib = 'max',
             size.title = 1)
plotLoadings(res_splsda, comp = 2, method = 'mean', contrib = 'max',
             size.title = 1)
```

# sPLS with regression mode - `EN` condition

```{r}
sel_samples <- which(condition == "EN")
set.seed(1205)
spls <- spls(X = log(t(abundances)+1)[sel_samples, ], 
             sapply(pathogenes[sel_samples, ], as.numeric) - 1, ncomp = 2, 
             mode = "regression", keepX = c(10,10), keepY = c(7,7))
plotIndiv(spls, comp = 1:2, rep.space= 'XY-variate', 
          ind.names = id_abundances[sel_samples], legend = F, 
          title = 'sPLS comp 1 - 2, XY-space',size.title = rel(2))
```


```{r ,cache=TRUE}
pls <- pls(as.matrix(sapply(clean_log_EN,as.numeric)), as.matrix(sapply(Y_EN,as.numeric)), ncomp = 2, mode = "regression")
spls <- spls(as.matrix(sapply(clean_log_EN,as.numeric)), as.matrix(sapply(Y_EN,as.numeric)), ncomp =2, 
             keepX= c(15,15), keepY=c(7,7), mode = "regression")
```

```{r}
tune.pls <- perf(pls, validation = "Mfold", folds = 20, 
                 progressBar = FALSE, nrepeat = 10)
tune.spls <- perf(spls, validation = "Mfold", folds = 20,
                  progressBar = FALSE, nrepeat = 10)
```


```{r}
tune.pls$Q2.total
plot(tune.pls$Q2.total)
abline(h=0.0975)
```

## Sample Plots

```{r}
plotIndiv(spls, comp = 1:2, rep.space= 'Y-variate', ind.names = clean_id[grep("EN",names(clean_id))],
legend = TRUE, title = 'sPLS comp 1 - 2, Y-space')
```

```{r}
plotIndiv(spls, comp = 1:2, rep.space= 'X-variate', ind.names = clean_id[grep("EN",names(clean_id))],
legend = TRUE, title = 'sPLS comp 1 - 2, X-space')
```

```{r}
plotIndiv(spls, comp = 1:2, rep.space= 'XY-variate', ind.names = clean_id[grep("EN",names(clean_id))],
legend = TRUE, title = 'sPLS comp 1 - 2, XY-space')
```

Individual plots can be displayed on three different subspaces spanned either by the X variable, the Y variable or the mean subspace in which coordinates are averaged from the first two subspaces (XY).

## Variable Plot

```{r}
plotVar(spls, comp =1:2, var.names = list(X.label = species, 
        Y.label = TRUE), cex = c(4, 5))
```

# sPLS with regression mode - `LBA` condition

```{r ,cache = TRUE}
pls <- pls(as.matrix(sapply(clean_log_LBA,as.numeric)), as.matrix(sapply(Y_LBA,as.numeric)), ncomp = 8, mode = "regression")
spls <- spls(as.matrix(sapply(clean_log_LBA,as.numeric)), as.matrix(sapply(Y_LBA,as.numeric)), ncomp =8, 
             keepX= c(15,15), keepY=c(7,7), mode = "regression")
```

```{r ,cache=TRUE}
tune.pls <- perf(pls, validation = "Mfold", folds = 20, 
                 progressBar = FALSE, nrepeat = 10)
tune.spls <- perf(spls, validation = "Mfold", folds = 20,
                  progressBar = FALSE, nrepeat = 10)
```

```{r ,cache=TRUE}
tune.pls$Q2.total
plot(tune.pls$Q2.total)
abline(h=0.0975)
```

## Sample Plots

```{r}
plotIndiv(spls, comp = 1:2, rep.space= 'Y-variate', ind.names = clean_id_LBA,
legend = F, title = 'sPLS comp 1 - 2, Y-space')
```

```{r}
plotIndiv(spls, comp = 1:2, rep.space= 'X-variate', ind.names = clean_id_LBA,
legend = F, title = 'sPLS comp 1 - 2, X-space')
```

```{r}
plotIndiv(spls, comp = 1:2, rep.space= 'XY-variate', ind.names = clean_id_LBA,
legend = F, title = 'sPLS comp 1 - 2, XY-space')
```
Individual plots can be displayed on three different subspaces spanned either by the X variable, the Y variable or the mean subspace in which coordinates are averaged from the first two subspaces (XY).

## Variable Plot

```{r}
plotVar(spls, comp =1:2, var.names = list(X.label = species, 
        Y.label = TRUE), cex = c(4, 5))
```


```{r heatmap1, fig.height = 10, fig.width = 10}
cim(spls, comp = 1, xlab = "virus", ylab = "genes")
selectVar(spls, comp = 1)$X$name
test <- cbind(Y,clean_log[,which(species%in%selectVar(spls, comp = 1)$X$name)])
cim(as.matrix(sapply(clean_log[,which(species%in%selectVar(spls, comp = 1)$X$name)],as.numeric)))
```


# Work on one condition

Regroupment of `RSV`, `PI.3`, `Coronavirus`

```{r}
group_virus<-sapply(Y,as.numeric)
group_virus<-group_virus-1
group_virus<-group_virus[,1]+group_virus[,2]+group_virus[,3]
group_virus[group_virus>0]<-1
group_virus <- as.factor(group_virus)

group_virus_EN <- group_virus[grep("EN",rownames(Y))]
group_virus_LBA <- group_virus[grep("LBA",rownames(Y))]
```

## PLS-DA on `group_virus` - `EN` condition

```{r ,cache=TRUE}
set.seed(11)
res_plsda <- plsda(X=clean_log_EN,Y=group_virus_EN, ncomp = nlevels(group_virus_EN))
res_perf <- perf(res_plsda, validation = 'Mfold', folds = 5,
                 progressBar = FALSE, nrepeat = 20)
plot(res_perf, overlay = 'measure', sd = TRUE)
plotIndiv(res_plsda , comp = c(1, 2), ind.names = FALSE, ellipse = TRUE, 
          legend = TRUE, title = 'PLS-DA (RSV,PI.3 et Coronavirus) - EN')
```

```{r ,cache=TRUE}
set.seed(33)
res_plsda <- tune.splsda(X=clean_log_EN,Y=group_virus_EN, 
                         ncomp = nlevels(group_virus_EN),
                         test.keepX = 1:20, validation = 'Mfold', 
                         folds = 10, dist = 'mahalanobis.dist', nrepeat = 10,
                         progressBar = F)

plot(res_plsda)

sel_keepX <- res_plsda$choice.keepX[1:2]
sel_keepX
```

```{r ,cache=TRUE}
res_splsda <- splsda(X=clean_log_EN,Y=group_virus_EN, 
                     ncomp = nlevels(group_virus_EN),
                     keepX = sel_keepX)

plotIndiv(res_splsda, comp = c(1,2), ind.names = FALSE, ellipse = TRUE, 
          legend = TRUE, title = 'sPLS-DA (RSV,PI.3 and Coronavirus) - EN')
```

```{r ,cache=TRUE}
test <- predict(res_splsda,clean_log_EN)
pred <- test$class$mahalanobis.dist[,2]
get.confusion_matrix(group_virus_EN,predicted=pred)
```


```{r ,cache=TRUE}
head(selectVar(res_splsda, comp = 1)$name)
plotLoadings(res_splsda, comp = 1, method = 'mean', contrib = 'max',
             size.title = 1)
plotLoadings(res_splsda, comp = 2, method = 'mean', contrib = 'max',
             size.title = 1)
```

```{r heatmap, fig.height = 10, fig.width = 10 ,eval=FALSE}
cim(res_splsda,comp=1)
test<-clean_log_EN[,which(species%in%selectVar(res_splsda, comp = 1)$name)]
cim(sapply(test,as.numeric),row.names = clean_id_EN)
```

**Presence vs Absence of viruses: Student tests**

```{r ,cache=TRUE}
selected <- selectVar(res_splsda, comp = 1)$name
for (ind in seq_along(selected)) {
  df <- data.frame(counts = clean_log_EN[,selected[ind]], 
                   condition = group_virus_EN)
  p <- ggplot(df, aes(x = condition, y = counts + 1, fill = group_virus_EN)) +
    geom_boxplot() + theme_bw() + scale_y_log10() + 
    scale_fill_manual(values = c("dodgerblue2","darkorange")) +
    ggtitle(selected[ind]) + ylab(expression(log[10] ~ "(count + 1)"))
  print(p)
}
```

$H_0$: true difference in means is equal to 0.

$H_1$: true difference in means is not equal to 0.

```{r}
all_pvals <- sapply(seq_along(selected), function(ind) {
  var_0 <- clean_log_EN[group_virus_EN == 0,selected[ind]]
  var_1 <- clean_log_EN[group_virus_EN == 1,selected[ind]]
  pval <- t.test(var_0, var_1)$p.value
})
res <- data.frame(bacteria = selected, pvalue = all_pvals,
                  FWER = p.adjust(all_pvals, method = "BH"))
res
```

```{r}
#cim(res_splsda, row.sideColors = color.mixo(group_virus_EN),row.names = clean_id_EN)
```

## PLS-DA on `group_virus` - `LBA` condition

```{r cache=TRUE}
set.seed(11)
res_plsda <- plsda(X=clean_log_LBA,Y=group_virus_LBA, ncomp = nlevels(group_virus_LBA))
res_perf <- perf(res_plsda, validation = 'Mfold', folds = 5,
                 progressBar = FALSE, nrepeat = 20)
plot(res_perf, overlay = 'measure', sd = TRUE)
plotIndiv(res_plsda , comp = c(1, 2), ind.names = FALSE, ellipse = TRUE, 
          legend = TRUE, title = 'PLS-DA (RSV,PI.3 et Coronavirus) - LBA')
```

```{r ,cache=TRUE}
set.seed(33)
res_plsda <- tune.splsda(X=clean_log_LBA,Y=group_virus_LBA, 
                         ncomp = nlevels(group_virus_LBA),
                         test.keepX = 1:20, validation = 'Mfold', 
                         folds = 10, dist = 'mahalanobis.dist', nrepeat = 10,
                         progressBar = F)

plot(res_plsda)

sel_keepX <- res_plsda$choice.keepX[1:2]
sel_keepX
```

```{r ,cache=TRUE}
res_splsda <- splsda(X=clean_log_LBA,Y=group_virus_LBA, 
                     ncomp = nlevels(group_virus_LBA),
                     keepX = sel_keepX)

plotIndiv(res_splsda, comp = c(1,2), ind.names = FALSE, ellipse = TRUE, 
          legend = TRUE, title = 'sPLS-DA (RSV,PI.3 et Coronavirus) - LBA')
```

```{r ,cache=TRUE}
test <- predict(res_splsda,clean_log_LBA)
pred <- test$class$mahalanobis.dist[,2]
get.confusion_matrix(group_virus_LBA,predicted=pred)
table(group_virus_LBA)
```

```{r }
head(selectVar(res_splsda, comp = 1)$name)
plotLoadings(res_splsda, comp = 1, method = 'mean', contrib = 'max',
             size.title = 1)
plotLoadings(res_splsda, comp = 2, method = 'mean', contrib = 'max',
             size.title = 1)
```

**Presence vs Absence of viruses: Student tests**

```{r ,cache=TRUE}
selected <- selectVar(res_splsda, comp = 1)$name
for (ind in seq_along(selected)) {
  df <- data.frame(counts = clean_log_LBA[,selected[ind]], 
                   condition = group_virus_LBA)
  p <- ggplot(df, aes(x = condition, y = counts + 1, fill = group_virus_LBA)) +
    geom_boxplot() + theme_bw() + scale_y_log10() + 
    scale_fill_manual(values = c("dodgerblue2","darkorange")) +
    ggtitle(selected[ind]) + ylab(expression(log[10] ~ "(count + 1)"))
  print(p)
}
```

$H_0$: true difference in means is equal to 0.

$H_1$: true difference in means is not equal to 0.

```{r}
all_pvals <- sapply(seq_along(selected), function(ind) {
  var_0 <- clean_log_LBA[group_virus_LBA == 0,selected[ind]]
  var_1 <- clean_log_LBA[group_virus_LBA == 1,selected[ind]]
  pval <- t.test(var_0, var_1)$p.value
})
res <- data.frame(bacteria = selected, pvalue = all_pvals,
                  FWER = p.adjust(all_pvals, method = "BH"))
res
```

```{r}
#cim(res_splsda, row.sideColors = color.mixo(group_virus_LBA),row.names = clean_id_LBA)
```

## PLS-DA on `PI.3` - `EN` condition

```{r ,cache=TRUE}
set.seed(11)
res_plsda <- plsda(X=clean_log_EN,Y=Y_EN$Ct.PI.3, ncomp = nlevels(Y_EN$Ct.PI.3))
res_perf <- perf(res_plsda, validation = 'Mfold', folds = 5,
                 progressBar = FALSE, nrepeat = 20)
plot(res_perf, overlay = 'measure', sd = TRUE)
plotIndiv(res_plsda , comp = c(1, 2), ind.names = FALSE, ellipse = TRUE, 
          legend = TRUE, title = 'PLS-DA (PI.3) - EN')
```

```{r ,cache=TRUE,eval=FALSE}
set.seed(33)
res_plsda <- tune.splsda(X=clean_log_EN,Y=Y_EN$Ct.PI.3, 
                         ncomp = nlevels(Y_EN$Ct.PI.3),
                         test.keepX = 1:20, validation = 'Mfold', 
                         folds = 10, dist = 'mahalanobis.dist', nrepeat = 10,
                         progressBar = F)

plot(res_plsda)

sel_keepX <- res_plsda$choice.keepX[1:2]
sel_keepX
```

**Error:** At least one class is not represented in one fold, which may unbalance the error rate.

```{r ,eval=FALSE}
res_splsda <- splsda(X=clean_log_EN,Y=Y_EN$Ct.PI.3, 
                     ncomp = nlevels(Y_EN$Ct.PI.3),
                     keepX = sel_keepX)

plotIndiv(res_splsda, comp = c(1,2), ind.names = FALSE, ellipse = TRUE, 
          legend = TRUE, title = 'sPLS-DA (PI.3) - EN')
```

```{r ,eval=FALSE}
head(selectVar(res_splsda, comp = 1)$name)
plotLoadings(res_splsda, comp = 1, method = 'mean', contrib = 'max',
             size.title = 1)
plotLoadings(res_splsda, comp = 2, method = 'mean', contrib = 'max',
             size.title = 1)
```

## PLS-DA on `PI.3` - `LBA` condition

```{r cache=TRUE,eval=FALSE}
set.seed(11)
res_plsda <- plsda(X=clean_log_LBA,Y=Y_LBA$Ct.PI.3, ncomp = nlevels(Y_LBA$Ct.PI.3))
res_perf <- perf(res_plsda, validation = 'Mfold', folds = 5,
                 progressBar = FALSE, nrepeat = 20)
plot(res_perf, overlay = 'measure', sd = TRUE)
plotIndiv(res_plsda , comp = c(1, 2), ind.names = FALSE, ellipse = TRUE, 
          legend = TRUE, title = 'PLS-DA (PI.3) - LBA')
```

**Error:** there is unbalanced class of `1`

```{r cache=TRUE,eval=FALSE}
set.seed(33)
res_plsda <- tune.splsda(X=clean_log_LBA,Y=Y_LBA$Ct.PI.3, 
                         ncomp = nlevels(Y_LBA$Ct.PI.3),
                         test.keepX = 1:20, validation = 'Mfold', 
                         folds = 10, dist = 'mahalanobis.dist', nrepeat = 10,
                         progressBar = F)

plot(res_plsda)

sel_keepX <- res_plsda$choice.keepX[1:2]
sel_keepX
```

**Error:** there is unbalanced class of `1`

```{r ,eval=FALSE}
res_splsda <- splsda(X=clean_log_LBA,Y=Y_LBA$Ct.PI.3, 
                     ncomp = nlevels(Y_LBA$Ct.PI.3),
                     keepX = sel_keepX)

plotIndiv(res_splsda, comp = c(1,2), ind.names = FALSE, ellipse = TRUE, 
          legend = TRUE, title = 'sPLS-DA (PI.3) - LBA')
```

```{r ,eval=FALSE}
head(selectVar(res_splsda, comp = 1)$name)
plotLoadings(res_splsda, comp = 1, method = 'mean', contrib = 'max',
             size.title = 1)
plotLoadings(res_splsda, comp = 2, method = 'mean', contrib = 'max',
             size.title = 1)
```

### Random Forest on `group_virus` - `EN` condition:

```{r ,cache=TRUE}
fit <- randomForest(group_virus_EN ~ ., data = X_EN,classwt=table(group_virus_EN), ntree=5000)
fit$confusion
```

### Random Forest on `group_virus` - `LBA` condition:

```{r ,cache=TRUE}
fit <- randomForest(group_virus_LBA ~ ., data = X_LBA,classwt=table(group_virus_LBA), ntree=5000)
fit$confusion
```


# Session information


```{r sessionInfo}
sessionInfo()
```


